// a modulok kozos definicioi

body {
    //TAG DEFINICIOK

    // A szovegben a feldolgozas soran hasznalt tag-ek C++-os (wstring)
    // definicioja. Ezeket a C++ kodok hasznaljak, ezt jeloli a _CPP vegzodes.
    // A veluk parhuzamos, a quex altal pattern-kent hasznalt definiciokat a
    // 'define' szekcio tartalmazza. Modositasnal es uj tag/karkter
    // felvetelenel a megfelelo _QX vegzodesu definiciokat is cserelni vagy 
    // felvenni kell. Ezeket a definiciokat hasznalja tovabba a printer.cpp
    // fajl is, csak wstring helyett sima string-kent. Modositasnal vagy
    // kiegeszitesnel azt a fajlt is modositani vagy kiegesziteni kell.

    // Az xml tag-ek helyett spec. karakterek vannak a kÃ©sÅ‘bbi feldolgozÃ¡st
    // megkÃ¶nnyÃ­tendÅ‘.
    const std::wstring SNT_OPEN_CPP     = L"ğŸ€°";
    const std::wstring SNT_CLOSE_CPP    = L"ğŸ€±";
    const std::wstring WS_OPEN_CPP      = L"ğŸ€²";
    const std::wstring WS_CLOSE_CPP     = L"ğŸ€³";
    const std::wstring WORD_OPEN_CPP      = L"ğŸ€´";
    const std::wstring WORD_CLOSE_CPP     = L"ğŸ€µ";
    const std::wstring PUNCT_OPEN_CPP      = L"ğŸ€¶";
    const std::wstring PUNCT_CLOSE_CPP     = L"ğŸ€·";

    // BASE_CLASS-ba nem tartozo karakterek csere karaktere:
    const std::wstring REPLACEMENTCHAR_CPP = L"ï¿½";


    // FUGGVENYEK

    // Az SNT es WS tag-ek osszes elofordulasanak torlese a kapott lexeme-bol,
    // javitott szoveg visszaadasa wstring-kent.
    // Megj.: Az sntcorr.qx-ben lenne a helye, de ha abban van 'body' szekcio,
    //      akkor az felulirja az ittenit, igy az sntcorr.qx-ben nem lenne
    //      hasznalhato a tobbi, itt deklaralt dolog sem. Szoval itt van, a
    //      tobbi modul meg nem hasznalja es kesz.
    std::wstring snt_boundary_correction(const wchar_t* lexeme) {
        std::wstring text(lexeme);
        delete_str(text, SNT_OPEN_CPP);
        delete_str(text, SNT_CLOSE_CPP);
        delete_str(text, WS_OPEN_CPP);
        delete_str(text, WS_CLOSE_CPP);
        return text;
    }

    // str osszes elofordulasanak torlese text-bol
    void delete_str(std::wstring &text, const std::wstring &str) {
        for(size_t pos = text.find(str);
            pos != std::wstring::npos;
            pos = text.find(str, pos)) {

            text.erase(pos, str.length());
        }
    }

}


define {
    // KarakterrosztÃ¡lyok: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // EMOTICONS: ~. A quex nem ismeri ezt a unicode blokkot, kÃ©zzel kell
    //      megadni.
    // BASE_CLASS: Alap karakterosztÃ¡ly, minden mÃ¡s ennek rÃ©szhalmaza kell
    //      legyen.
    // NEWLINE: Ãšjsor karakterek.
    //      TODO: Legyen NEWLINE_CHAR es NEWLINE kulon, hogy az osszetettek is
    //          egynek szamitsanak.
    // SPACE: Minden wspace a base_class-bÃ³l, az Ãºjsor karakterek kivÃ©telÃ©vel.
    //      SOFT HYPHEN (00AD) is benne van.
    //      Ez a rÃ©gi: ([ \n\t]) - nincs kÃ¼lÃ¶nbsÃ©g a ws Ã©s nl kÃ¶zÃ¶tt.
    // WSPACE: Minden white space a base class-bol.
    // WORDCHAR: szÃ³ban szerepelhetÅ‘ karakterek (pont is benne van, l. nytud.hu)
    //      eredetileg html entitÃ¡sokat is tartalmazott, de ki lettek vÃ©ve
    //      Ez a rÃ©gi: ([a-zA-ZÃ¡Ã©Ã­Ã³Ã¶Å‘ÃºÃ¼Å±ÃÃ‰ÃÃ“Ã–ÅÃšÃœÅ°\-.Â§%Â°0-9Â¡Â£Â¥Â¦Â©ÂªÂ«Â¬Â®Â¯Â±Â³ÂµÂ¶Â¹ÂºÂ»Â¼Â¾Â¿Ä„ÅÄ½ÅšÅ ÅÅ¤Å¹Å½Å»Ä…Å‚Ä¾Å›Å¡ÅŸÅ¥ÅºÅ¾Å¼Å”Ã‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÄ˜Ã‹ÄšÃÄÄÅƒÅ‡Ã”Å˜Å®ÃÅ¢ÃŸÅ•Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÄ™Ã«Ä›Ã®ÄÄ‘Å„ÅˆÃ´Å™Å¯Ã½Å£])
    //      TODO: html entitÃ¡sok kezelÃ©sÃ©t kitalÃ¡lni (elÅ‘feldolgozÃ¡s, Ã©s
    //          utf8-ra alakÃ­tÃ¡s?)
    //      Figyelni: az eredeti a '_'-t nem tartalmazza (hun_token-nel lehet
    //          fontos)!
    // WORDCHAR2: szÃ³ban szerepelhetÅ‘ karakterek, pont nÃ©lkÃ¼l
    // NONWORDCHAR: nem-szoalkoto kakaktrerek (pont nincs benne, tehat a sima
    //      WORDCHAR komplementere)
    //      Ez a regi: [^a-zA-ZÃ¡Ã©Ã­Ã³Ã¶ÃµÃºÃ¼Ã»ÃÃ‰ÃÃ“Ã–Ã•ÃšÃœÃ›\-.Â§%Â°0-9Â¡Â£Â¥Â¦Â©ÂªÂ«Â¬Â®Â¯Â±Â³ÂµÂ¶Â¹ÂºÂ»Â¼Â¾Â¿Ã€Ã‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃŠÃ‹ÃŒÃÃÃÃ‘Ã’Ã”Ã˜Ã™ÃÃÃŸÃ Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨ÃªÃ«Ã¬Ã®Ã¯Ã°Ã±Ã²Ã´Ã¸Ã¹Ã½Ã¾]
    //      Figyelni: a hun_token is hasznalja, de az a '_'-t is tartalmazza!
    // LOWER: kisbetÅ±k + nÃ©hÃ¡ny szimbÃ³lum Csaba kÃ³dja alapjÃ¡n
    //      Ez a rÃ©gi: ([a-zÂµÂ¿Â»Â¶Â±Â¼Â¾Â¹Â³Ã¡Ã ÄƒÃ¢Ã¥Ã¤Ã£Ä…Ã¦Ä‡ÄÃ§ÄÄ‘Ã°Ã©Ã¨ÃªÄ›Ã«Ä™Ã­Ã¬Ã®Ã¯ÄºÄ¾Å‚Å„ÅˆÃ±Ã³Ã²Ã´Ã¶Å‘ÃµÃ¸ÂºÅ•Å™Å›Å¡ÅŸÃŸÅ¥Å£ÃºÃ¹Ã»Å¯Ã¼Å±Ã½ÅºÅ¾Å¼Ã¾])
    //      Megj.: union(\P{Lowercase}, \P{Other_Lowercase} is lehet hogy jÃ³
    //          \G{Lowercase_Letter} helyett -- vajon van kÃ¼lÃ¶nbsÃ©g?
    // UPPER: nagybetÅ±k + nÃ©hÃ¡ny szimbÃ³lum Csaba kÃ³dja alapjÃ¡n
    //      Ez a rÃ©gi: ([A-ZÃÃ‰ÃÃ“Ã–Ã•ÃšÃœÃ›Â§Â¡Â£Â¥Â¦Â©ÂªÂ«Â¬Â®Â¯Ã€Ã‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃŠÃ‹ÃŒÃÃÃÃ‘Ã’Ã”Ã˜Ã™ÃÃ])
    // CHARINSNT: mondatban szerepelhetÅ‘, nem szÃ³alkotÃ³ Ã©s nem is mondathatÃ¡rolÃ³
    //      karakterek (zÃ¡rÃ³jel, idÃ©zÅ‘jel, szÃ³kÃ¶z, stb.)
    // BOUNDARY: egyszerÅ± mondathatÃ¡rolÃ³ karakterek (pont, felkiÃ¡ltÃ³jel,
    //      kÃ©rdÅ‘jel)
    //      Megj.: a szÃ³n belÃ¼li pont mÃ¡shogy van kezelve.
    // SNTCHAR: nem mondathatÃ¡rolÃ³ karakter ami nem is sortÃ¶rÃ©s
    // SNTBEGINCHR: mondatkezdÅ‘ karakter (pont is lehet, pl. a ".hu vita a
    //           neten.")
    // ENDQUOPAR: zÃ¡rÃ³ zÃ¡rÃ³- Ã©s idÃ©zÅ‘jelek
    //      Ez a rÃ©gi: ("\""|"''"|"'"|")"|"]")
    //      Megj.: mondathatÃ¡r (BOUNDARY) utÃ¡n is kÃ¶vetkezhetnek (l. SNTEND)
    //      TODO: unicode-osÃ­tani
    // INPARENTCHR: BRACKET_PART szabÃ¡lyban zÃ¡rÃ³jelen belÃ¼l alapbÃ³l megengedett
    //      karakterek osztÃ¡lya
    // COMMACHR: COMMA_PART szabÃ¡lyban szerepelhetÅ‘ vesszÅ‘-szerÅ± karakterek

    EMOTICONS   [\U1F600-\U1F915]

    BASE_CLASS  [: union( \P{Block=Basic_Latin},
                          \P{Block=Latin-1_Supplement},
                          \P{Block=Latin_Extended-A},
                          \P{Block=Latin_Extended-B},
                          \P{Block=Latin_Extended-C},
                          \P{Block=Latin_Extended-D},
                          \P{Block=Cyrillic},
                          \P{Block=Cyrillic_Supplement},
                          \P{Block=Greek_and_Coptic},
                          \P{Block=Greek_Extended},
                          \P{Block=Ancient_Greek_Numbers},
                          \P{Block=Combining_Diacritical_Marks},
                          \P{Block=Combining_Diacritical_Marks_Supplement},
                          \P{Block=General_Punctuation},
                          \P{Block=Supplemental_Punctuation},
                          \P{Block=Specials},
                          \P{Block=Mathematical_Operators},
                          \P{Block=Supplemental_Mathematical_Operators},
                          \P{Block=Geometric_Shapes},
                          \P{Block=Arrows},
                          \P{Block=Supplemental_Arrows-A},
                          \P{Block=Supplemental_Arrows-B},
                          /* \P{Block=Private_Use_Area}, */
                          /* \P{Block=Supplementary_Private_Use_Area-A}, */
                          /* \P{Block=Supplementary_Private_Use_Area-B}, */
                          \P{Block=Spacing_Modifier_Letters},
                          \P{Block=Alphabetic_Presentation_Forms},
                          \P{Block=Phonetic_Extensions},
                          \P{Block=Phonetic_Extensions_Supplement},
                          \P{Block=Currency_Symbols},
                          \P{Block=Letterlike_Symbols},
                          \P{Block=Mathematical_Alphanumeric_Symbols},
                          \P{Block=Miscellaneous_Mathematical_Symbols-A},
                          \P{Block=Miscellaneous_Mathematical_Symbols-B},
                          \P{Block=Miscellaneous_Symbols_and_Arrows},
                          \P{Block=Miscellaneous_Technical},
                          \P{Block=Musical_Symbols},
                          \P{Block=Miscellaneous_Symbols},
                          {EMOTICONS} ) :]

    NEWLINE     [: intersection( {BASE_CLASS}, [\n\r\f\v] ) :]

    SPACE       [: intersection( {BASE_CLASS}, union(difference(\P{White_Space}, {NEWLINE}), [Â­]) ) :]

    WSPACE      ({NEWLINE}|{SPACE})

    WORDCHAR    [: intersection( {BASE_CLASS}, union(\P{Alphabetic}, \G{Number}, [.\-_Â§%Â°Â¡Â£Â¥Â¦Â©ÂªÂ«Â¬Â®Â¯Â±ÂµÂ¶Â»Â¿/]) ) :]

    WORDCHAR2   [: intersection( {BASE_CLASS}, union(\P{Alphabetic}, \G{Number},  [\-_Â§%Â°Â¡Â£Â¥Â¦Â©ÂªÂ«Â¬Â®Â¯Â±ÂµÂ¶Â»Â¿/]) ) :]

    NONWORDCHAR [: difference( {BASE_CLASS}, {WORDCHAR}) :]

    LOWER       [: intersection( {BASE_CLASS}, union(\G{Lowercase_Letter}, [Â¿Â»Â¶Â±Â¼Â¾Â¹Â³Ã¸Âº])) :]

    UPPER       [: intersection( {BASE_CLASS}, union(\G{Uppercase_Letter}, [Â§Â¡Â£Â¥Â¦Â©ÂªÂ«Â¬Â®Â¯]) ) :]

    CHARINSNT   [: intersection( {BASE_CLASS}, [\(\)\-[\],; "] ) :]

    BOUNDARY    [: intersection( {BASE_CLASS}, [.?!] ) :]

    SNTCHAR     [: intersection( {BASE_CLASS}, [^.?!\n] ) :]

    SNTBEGINCHR [: intersection( {BASE_CLASS}, [^?!\n ] ) :]

    ENDQUOPAR   [: intersection( {BASE_CLASS}, ["'\)\]] ) :]

    INPARENTCHR [: intersection( {BASE_CLASS}, difference([^.!?\)], {NEWLINE}) ) :]

    COMMACHR    [: intersection( {BASE_CLASS}, [,;:] ) :]


    // A szovegben a feldolgozas soran hasznalt tag-ek quex-es (pattern)
    // definicioja:
    SNT_OPEN_QX     \U01F030 // ğŸ€°
    SNT_CLOSE_QX    \U01F031 // ğŸ€±
    WS_OPEN_QX      \U01F032 // ğŸ€²
    WS_CLOSE_QX     \U01F033 // ğŸ€³
    WORD_OPEN_QX    \U01F034 // ğŸ€´
    WORD_CLOSE_QX   \U01F035 // ğŸ€µ
    PUNCT_OPEN_QX   \U01F036 // ğŸ€¶
    PUNCT_CLOSE_QX  \U01F037 // ğŸ€·

    // egyebek:
    // tetszoleges egesz szam:
    INT             [\-+]?[0-9]+
    // romai szamok (http://stackoverflow.com/a/267405 felhasznalasaval)
    ROMAN_NUM       "M"{0,4}("CM"|"CD"|("D"?"C"{0,3}))("XC"|"XL"|("L"?"X"{0,3}))("IX"|"IV"|("V"?"I"{0,3}))
    // BASE_CLASS-ba nem tartozo karakterek csere karaktere:
    /* REPLACEMENTCHAR_QX "ï¿½" */

    // ws szekvencia benne legfeljebb 1 db sortoressel (mondaton belul)
    WS_SEQ_INSNT            (({SPACE}+{NEWLINE}?{SPACE}*)|({NEWLINE}{SPACE}*))
    // megtag-gelt ws_seq
    TAGGED_WS_SEQ_INSNT     ({WS_OPEN_QX}{WS_SEQ_INSNT}{WS_CLOSE_QX})
    // mondathatar: mondatzaro tag + taggelt space-sorozat + mondatnyito tag
    SENTENCE_BOUNDARY       ({SNT_CLOSE_QX}{TAGGED_WS_SEQ_INSNT}{SNT_OPEN_QX})
    // ugyan ez "." utan
    DOT_SENTENCE_BOUNDARY   ("."{SENTENCE_BOUNDARY})
    // megtag-gelt ws_seq, benne barhany sortores (mondatkozi)
    TAGGED_WS_SEQ     ({WS_OPEN_QX}{WSPACE}*{WS_CLOSE_QX})
}


// vim:set syntax=cpp:

